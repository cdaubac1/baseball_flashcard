const express = require('express');
const cors = require('cors');
const axios = require('axios');

const app = express();
app.use(cors());
app.use(express.json());
app.use(express.static('.'));

// Configuration - Set these as environment variables
const SLUGGER_CONFIG = {
  baseUrl: process.env.SLUGGER_BASE_URL || "https://1ywv9dczq5.execute-api.us-east-2.amazonaws.com/ALPBAPI",
  apiKey: process.env.SLUGGER_API_KEY || "your-api-key-here"
};

// Helper function to make authenticated requests to SLUGGER API
async function sluggerRequest(endpoint, params = {}) {
  try {
    const response = await axios.get(`${SLUGGER_CONFIG.baseUrl}${endpoint}`, {
      headers: {
        'x-api-key': SLUGGER_CONFIG.apiKey,
        'Content-Type': 'application/json'
      },
      params: {
        ...params,
        limit: params.limit || 1000 // Get max results per page
      }
    });
    return response.data;
  } catch (error) {
    console.error(`Error calling ${endpoint}:`, error.message);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
    }
    throw error;
  }
}

// Helper function to fetch all pages of pitch data
async function fetchAllPitches(params) {
  let allPitches = [];
  let page = 1;
  let hasMore = true;

  while (hasMore) {
    const response = await sluggerRequest('/pitches', {
      ...params,
      page,
      order: 'ASC' // Get chronological order for proper processing
    });

    if (response.success && response.data) {
      const pitches = Array.isArray(response.data) ? response.data : [response.data];
      allPitches = allPitches.concat(pitches);
      
      // Check if there are more pages
      // Assuming if we get less than limit, we're done
      hasMore = pitches.length === (params.limit || 1000);
      page++;
      
      console.log(`Fetched page ${page - 1}: ${pitches.length} pitches`);
    } else {
      hasMore = false;
    }
  }

  return allPitches;
}

function transformPitchDataToTeams(pitchData, existingData = {}) {
  const teamsData = { ...existingData };
  const batterMap = new Map();

  // Initialize batterMap with existing data
  Object.entries(teamsData).forEach(([team, batters]) => {
    batters.forEach(batter => {
      const key = `${team}_${batter.batter}`;
      batterMap.set(key, batter);
    });
  });

  pitchData.forEach(pitch => {
    // Extract batter and team info from the pitch data structure
    // Adjust these field names based on actual API response
    const batterName = pitch.batter?.player_name || pitch.batter_name;
    const teamName = pitch.batter?.team?.team_name || pitch.batter_team_name;
    const pitcherName = pitch.pitcher?.player_name || pitch.pitcher_name;
    
    if (!batterName || !teamName || !pitcherName) return;

    const batterKey = `${teamName}_${batterName}`;

    if (!teamsData[teamName]) {
      teamsData[teamName] = [];
    }

    let batterData = batterMap.get(batterKey);
    
    if (!batterData) {
      batterData = {
        batter: batterName,
        handedness: pitch.batter?.player_batting_handedness === 'Left' ? 'LHB' : 'RHB',
        pitcher: pitcherName,
        pitcherThrows: pitch.pitcher?.player_pitching_handedness === 'Left' ? 'LHP' : 'RHP',
        context: `${pitch.top_or_bottom || 'Top'} ${pitch.inning || 1}, ${pitch.balls || 0}-${pitch.strikes || 0}`,
        battingOrder: pitch.pa_of_inning || teamsData[teamName].length + 1,
        pitchZones: [],
        zoneAnalysis: {},
        stats: {
          totalPitches: 0,
          strikes: 0,
          balls: 0,
          swings: 0,
          contact: 0,
          fouls: 0,
          whiffs: 0,
          firstPitchPitches: 0,
          firstPitchSwings: 0,
          weakContact: 0,
          hardContact: 0
        },
        plateAppearances: [],
        atBats: [],
        stolenBases: 0,
        caughtStealing: 0,
        bunts: 0,
        strikeoutSequences: [],
        tendencies: {
          firstStrike: 'Calculating...',
          buntThreat: 'Low',
          stealThreat: 'Low',
          spray: 'All fields'
        },
        powerSequence: 'Calculating...'
      };
      
      batterMap.set(batterKey, batterData);
      teamsData[teamName].push(batterData);
    }

    const paKey = `${pitch.inning}_${pitch.pa_of_inning}`;
    let currentPA = batterData.plateAppearances.find(pa => pa.key === paKey);
    
    if (!currentPA) {
      currentPA = {
        key: paKey,
        pitches: [],
        result: null,
        isFirstPitch: true
      };
      batterData.plateAppearances.push(currentPA);
    }

    const pitchType = getPitchAbbreviation(pitch.tagged_pitch_type || pitch.auto_pitch_type);
    currentPA.pitches.push({
      type: pitchType,
      call: pitch.pitch_call,
      count: `${pitch.balls}-${pitch.strikes}`
    });

    batterData.stats.totalPitches++;
    
    if (currentPA.isFirstPitch) {
      batterData.stats.firstPitchPitches++;
      if (['StrikeSwinging', 'FoulBall', 'FoulBallFieldable', 'FoulBallNotFieldable', 'InPlay'].includes(pitch.pitch_call)) {
        batterData.stats.firstPitchSwings++;
      }
      currentPA.isFirstPitch = false;
    }
    
    if (['StrikeCalled', 'StrikeSwinging', 'FoulBall', 'FoulBallFieldable', 'FoulBallNotFieldable'].includes(pitch.pitch_call)) {
      batterData.stats.strikes++;
    }
    if (pitch.pitch_call === 'BallCalled') {
      batterData.stats.balls++;
    }
    if (['StrikeSwinging', 'FoulBall', 'FoulBallFieldable', 'FoulBallNotFieldable', 'InPlay'].includes(pitch.pitch_call)) {
      batterData.stats.swings++;
    }
    if (['FoulBall', 'FoulBallFieldable', 'FoulBallNotFieldable', 'InPlay'].includes(pitch.pitch_call)) {
      batterData.stats.contact++;
    }
    if (['FoulBall', 'FoulBallFieldable', 'FoulBallNotFieldable'].includes(pitch.pitch_call)) {
      batterData.stats.fouls++;
    }
    if (pitch.pitch_call === 'StrikeSwinging') {
      batterData.stats.whiffs++;
    }

    if (pitch.exit_speed && pitch.pitch_call === 'InPlay') {
      if (pitch.exit_speed >= 95) {
        batterData.stats.hardContact++;
      } else if (pitch.exit_speed < 70) {
        batterData.stats.weakContact++;
      }
    }

    if (pitch.play_result) {
      currentPA.result = pitch.play_result;
      
      if (pitch.play_result.includes('StolenBase') || pitch.k_or_bb === 'Stolen Base') {
        batterData.stolenBases++;
      }
      if (pitch.play_result.includes('CaughtStealing')) {
        batterData.caughtStealing++;
      }
      
      if (pitch.play_result.includes('Bunt') || pitch.pitch_call.includes('Bunt')) {
        batterData.bunts++;
      }
      
      if (pitch.pitch_call === 'InPlay' && pitch.angle !== null && pitch.exit_speed) {
        batterData.atBats.push({
          angle: pitch.angle,
          distance: pitch.distance || 0,
          exitSpeed: pitch.exit_speed,
          result: pitch.play_result
        });
      }
    }

    if (pitch.k_or_bb === 'Strikeout' && currentPA.pitches.length >= 2) {
      const lastTwo = currentPA.pitches.slice(-2);
      batterData.strikeoutSequences.push(
        `${lastTwo[0].type} â†’ ${lastTwo[1].type}`
      );
    }

    if (pitch.plate_loc_side !== null && pitch.plate_loc_height !== null) {
      const zone = getZoneFromLocation(pitch.plate_loc_side, pitch.plate_loc_height, batterData.handedness);
      
      if (!batterData.zoneAnalysis[zone]) {
        batterData.zoneAnalysis[zone] = {
          pitches: 0,
          swings: 0,
          whiffs: 0,
          fouls: 0,
          weakContact: 0,
          hardHits: 0,
          contact: 0
        };
      }
      
      const zoneStats = batterData.zoneAnalysis[zone];
      zoneStats.pitches++;
      
      if (['StrikeSwinging', 'FoulBall', 'FoulBallFieldable', 'FoulBallNotFieldable', 'InPlay'].includes(pitch.pitch_call)) {
        zoneStats.swings++;
      }
      if (pitch.pitch_call === 'StrikeSwinging') {
        zoneStats.whiffs++;
      }
      if (['FoulBall', 'FoulBallFieldable', 'FoulBallNotFieldable'].includes(pitch.pitch_call)) {
        zoneStats.fouls++;
      }
      if (['FoulBall', 'FoulBallFieldable', 'FoulBallNotFieldable', 'InPlay'].includes(pitch.pitch_call)) {
        zoneStats.contact++;
      }
      if (pitch.exit_speed && pitch.pitch_call === 'InPlay') {
        if (pitch.exit_speed >= 95) {
          zoneStats.hardHits++;
        } else if (pitch.exit_speed < 70) {
          zoneStats.weakContact++;
        }
      }

      const xPos = 50 + (pitch.plate_loc_side * 25);
      const yPos = 100 - ((pitch.plate_loc_height - 1.5) / 2 * 100);
      
      let isGoodPitch = false;
      
      if (pitch.pitch_call === 'StrikeSwinging') {
        isGoodPitch = true;
      } else if (pitch.pitch_call === 'StrikeCalled') {
        isGoodPitch = true;
      } else if (['FoulBall', 'FoulBallFieldable', 'FoulBallNotFieldable'].includes(pitch.pitch_call)) {
        isGoodPitch = true;
      } else if (pitch.exit_speed && pitch.exit_speed < 70) {
        isGoodPitch = true;
      } else if (pitch.pitch_call === 'BallCalled') {
        isGoodPitch = false;
      } else if (pitch.exit_speed && pitch.exit_speed >= 95) {
        isGoodPitch = false;
      } else if (pitch.pitch_call === 'InPlay') {
        isGoodPitch = false;
      }

      batterData.pitchZones.push({
        position: [
          Math.max(0, Math.min(100, xPos)),
          Math.max(0, Math.min(100, yPos))
        ],
        pitch: pitchType,
        good: isGoodPitch,
        zone: zone
      });
    }
  });

  // Calculate tendencies
  Object.values(teamsData).forEach(batters => {
    batters.forEach(batter => {
      if (batter.stats.totalPitches > 0) {
        if (batter.stats.firstPitchPitches > 0) {
          const firstPitchSwingRate = (batter.stats.firstPitchSwings / batter.stats.firstPitchPitches * 100);
          batter.tendencies.firstStrike = firstPitchSwingRate > 50 ? 
            `Aggressive (${firstPitchSwingRate.toFixed(0)}%)` : 
            `Patient (${firstPitchSwingRate.toFixed(0)}%)`;
        }
        
        const stealAttempts = batter.stolenBases + batter.caughtStealing;
        if (stealAttempts >= 3) {
          const successRate = (batter.stolenBases / stealAttempts * 100).toFixed(0);
          batter.tendencies.stealThreat = `High (${batter.stolenBases}/${stealAttempts} - ${successRate}%)`;
        } else if (stealAttempts > 0) {
          batter.tendencies.stealThreat = `Moderate (${batter.stolenBases}/${stealAttempts})`;
        } else {
          batter.tendencies.stealThreat = 'Low';
        }
        
        if (batter.bunts >= 3) {
          batter.tendencies.buntThreat = `High (${batter.bunts} bunts)`;
        } else if (batter.bunts > 0) {
          batter.tendencies.buntThreat = `Moderate (${batter.bunts} bunts)`;
        } else {
          batter.tendencies.buntThreat = 'Low';
        }
        
        if (batter.atBats.length >= 5) {
          const pullCount = batter.atBats.filter(ab => {
            if (batter.handedness === 'LHB') return ab.angle < -15;
            else return ab.angle > 15;
          }).length;
          
          const oppoCount = batter.atBats.filter(ab => {
            if (batter.handedness === 'LHB') return ab.angle > 15;
            else return ab.angle < -15;
          }).length;
          
          const pullPct = (pullCount / batter.atBats.length * 100);
          const oppoPct = (oppoCount / batter.atBats.length * 100);
          
          if (pullPct > 60) {
            batter.tendencies.spray = `Pull hitter (${pullPct.toFixed(0)}%)`;
          } else if (oppoPct > 40) {
            batter.tendencies.spray = `Opposite field (${oppoPct.toFixed(0)}%)`;
          } else {
            batter.tendencies.spray = `All fields (P:${pullPct.toFixed(0)}% O:${oppoPct.toFixed(0)}%)`;
          }
        }
        
        if (batter.strikeoutSequences.length > 0) {
          const sequenceCounts = {};
          batter.strikeoutSequences.forEach(seq => {
            sequenceCounts[seq] = (sequenceCounts[seq] || 0) + 1;
          });
          const mostCommon = Object.entries(sequenceCounts)
            .sort((a, b) => b[1] - a[1])[0];
          batter.powerSequence = `${mostCommon[0]} (${mostCommon[1]}x)`;
        }
      }
    });
  });

  return teamsData;
}

function getZoneFromLocation(plateSide, plateHeight, handedness) {
  const isInside = (handedness === 'LHB' && plateSide > 0.33) || 
                   (handedness === 'RHB' && plateSide < -0.33);
  const isOutside = (handedness === 'LHB' && plateSide < -0.33) || 
                    (handedness === 'RHB' && plateSide > 0.33);
  
  const horizontal = isInside ? 'In' : (isOutside ? 'Out' : 'Mid');
  
  const isHigh = plateHeight > 3.0;
  const isLow = plateHeight < 2.0;
  const vertical = isHigh ? 'High' : (isLow ? 'Low' : 'Mid');
  
  return `${vertical}-${horizontal}`;
}

function getPitchAbbreviation(pitchType) {
  if (!pitchType) return 'F';
  
  const abbrev = {
    'Fastball': 'F',
    'Four-Seam': 'F',
    'TwoSeamFastball': 'F',
    'Sinker': 'S',
    'Cutter': 'C',
    'Slider': 'S',
    'Curveball': 'C',
    'Changeup': 'CH',
    'ChangeUp': 'CH',
    'Splitter': 'CH',
    'Knuckleball': 'CH'
  };
  
  return abbrev[pitchType] || 'F';
}

// API Routes

app.get('/api/teams/range', async (req, res) => {
  try {
    const { startDate, endDate } = req.query; // Format: YYYYMMDD
    
    if (!startDate || !endDate) {
      return res.status(400).json({ error: 'startDate and endDate are required' });
    }
    
    console.log(`Fetching data from ${startDate} to ${endDate}`);
    
    // Convert YYYYMMDD to YYYY-MM-DD format for API
    const formattedStartDate = `${startDate.substring(0, 4)}-${startDate.substring(4, 6)}-${startDate.substring(6, 8)}`;
    const formattedEndDate = `${endDate.substring(0, 4)}-${endDate.substring(4, 6)}-${endDate.substring(6, 8)}`;
    
    // Fetch all pitches for the date range
    const pitches = await fetchAllPitches({
      date_range_start: formattedStartDate,
      date_range_end: formattedEndDate
    });
    
    console.log(`Fetched ${pitches.length} total pitches`);
    
    const teamsData = transformPitchDataToTeams(pitches);
    
    res.json({
      teamsData,
      metadata: {
        startDate,
        endDate,
        filesProcessed: pitches.length,
        filesSkipped: 0
      }
    });
  } catch (error) {
    console.error('Error fetching range data:', error);
    res.status(500).json({ 
      error: 'Failed to fetch data',
      details: error.message 
    });
  }
});

app.get('/api/game/:date/:stadium', async (req, res) => {
  try {
    const { date, stadium } = req.params;
    
    // Convert YYYYMMDD to YYYY-MM-DD format
    const formattedDate = `${date.substring(0, 4)}-${date.substring(4, 6)}-${date.substring(6, 8)}`;
    
    console.log(`Fetching game data for ${formattedDate} at ${stadium}`);
    
    // Fetch pitches for specific game
    const pitches = await fetchAllPitches({
      date: formattedDate,
      ballpark_name: stadium
    });
    
    const teamsData = transformPitchDataToTeams(pitches);
    
    res.json(teamsData);
  } catch (error) {
    console.error('Error fetching game data:', error);
    res.status(500).json({ 
      error: 'Failed to fetch game data',
      details: error.message 
    });
  }
});

app.get('/api/games/range', async (req, res) => {
  try {
    const { startDate, endDate } = req.query;
    
    if (!startDate || !endDate) {
      return res.status(400).json({ error: 'startDate and endDate are required' });
    }
    
    // Convert dates
    const formattedStartDate = `${startDate.substring(0, 4)}-${startDate.substring(4, 6)}-${startDate.substring(6, 8)}`;
    const formattedEndDate = `${endDate.substring(0, 4)}-${endDate.substring(4, 6)}-${endDate.substring(6, 8)}`;
    
    // Fetch games using the /games endpoint
    const response = await sluggerRequest('/games', {
      date_range_start: formattedStartDate,
      date_range_end: formattedEndDate,
      limit: 1000
    });
    
    const games = Array.isArray(response.data) ? response.data : [response.data];
    
    const formattedGames = games.map(game => ({
      date: game.date.replace(/-/g, ''),
      stadium: game.ballpark?.ballpark_name || 'Unknown',
      filename: `${game.date}-${game.ballpark?.ballpark_name}_unverified.csv`
    }));
    
    res.json({ games: formattedGames });
  } catch (error) {
    console.error('Error listing games:', error);
    res.status(500).json({ 
      error: 'Failed to list games',
      details: error.message 
    });
  }
});

app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'Server is running',
    apiConfigured: !!SLUGGER_CONFIG.apiKey && SLUGGER_CONFIG.apiKey !== 'your-api-key-here'
  });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}/`);
  console.log(`API Base URL: ${SLUGGER_CONFIG.baseUrl}`);
  console.log(`API Key configured: ${SLUGGER_CONFIG.apiKey !== 'your-api-key-here'}`);
});